// Code generated by go generate; DO NOT EDIT
// This file is generated by go generate at 2022-11-23 18:16:28.725402023 +0800 CST m=+0.004536238

package entity

import (
	"testing"

	"github.com/stretchr/testify/assert"
)


func TestIndexFlat(t *testing.T){
	

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		
		idx0, err := NewIndexFlat(mt, 
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "Flat", idx0.Name())
		assert.EqualValues(t, "FLAT", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
	})
}

func TestIndexBinFlat(t *testing.T){
	
	var nlist int

	mt := HAMMING
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist = 10
		idx0, err := NewIndexBinFlat(mt, 
			nlist,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "BinFlat", idx0.Name())
		assert.EqualValues(t, "BIN_FLAT", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.True(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist = 0
		idx0, err := NewIndexBinFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist = 65537
		idx1, err := NewIndexBinFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
	})
}

func TestIndexIvfFlat(t *testing.T){
	
	var nlist int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist = 10
		idx0, err := NewIndexIvfFlat(mt, 
			nlist,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "IvfFlat", idx0.Name())
		assert.EqualValues(t, "IVF_FLAT", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist = 0
		idx0, err := NewIndexIvfFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist = 65537
		idx1, err := NewIndexIvfFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
	})
}

func TestIndexBinIvfFlat(t *testing.T){
	
	var nlist int

	mt := HAMMING
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist = 10
		idx0, err := NewIndexBinIvfFlat(mt, 
			nlist,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "BinIvfFlat", idx0.Name())
		assert.EqualValues(t, "BIN_IVF_FLAT", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.True(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist = 0
		idx0, err := NewIndexBinIvfFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist = 65537
		idx1, err := NewIndexBinIvfFlat(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
	})
}

func TestIndexIvfSQ8(t *testing.T){
	
	var nlist int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist = 10
		idx0, err := NewIndexIvfSQ8(mt, 
			nlist,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "IvfSQ8", idx0.Name())
		assert.EqualValues(t, "IVF_SQ8", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist = 0
		idx0, err := NewIndexIvfSQ8(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist = 65537
		idx1, err := NewIndexIvfSQ8(mt, 
			nlist,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
	})
}

func TestIndexIvfPQ(t *testing.T){
	
	var nlist int
	var m int
	var nbits int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist, m, nbits = 10, 8, 8
		idx0, err := NewIndexIvfPQ(mt, 
			nlist,
			m,
			nbits,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "IvfPQ", idx0.Name())
		assert.EqualValues(t, "IVF_PQ", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist, m, nbits = 0, 8, 8
		idx0, err := NewIndexIvfPQ(mt, 
			nlist,
			m,
			nbits,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist, m, nbits = 65537, 8, 8
		idx1, err := NewIndexIvfPQ(mt, 
			nlist,
			m,
			nbits,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
		nlist, m, nbits = 10, 8, 0
		idx2, err := NewIndexIvfPQ(mt, 
			nlist,
			m,
			nbits,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx2)
		
		nlist, m, nbits = 10, 8, 17
		idx3, err := NewIndexIvfPQ(mt, 
			nlist,
			m,
			nbits,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx3)
		
	})
}

func TestIndexHNSW(t *testing.T){
	
	var M int
	var efConstruction int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		M, efConstruction = 16, 40
		idx0, err := NewIndexHNSW(mt, 
			M,
			efConstruction,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "HNSW", idx0.Name())
		assert.EqualValues(t, "HNSW", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		M, efConstruction = 3, 40
		idx0, err := NewIndexHNSW(mt, 
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		M, efConstruction = 65, 40
		idx1, err := NewIndexHNSW(mt, 
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
		M, efConstruction = 16, 7
		idx2, err := NewIndexHNSW(mt, 
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx2)
		
		M, efConstruction = 16, 513
		idx3, err := NewIndexHNSW(mt, 
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx3)
		
	})
}

func TestIndexIvfHNSW(t *testing.T){
	
	var nlist int
	var M int
	var efConstruction int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		nlist, M, efConstruction = 10, 16, 40
		idx0, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "IvfHNSW", idx0.Name())
		assert.EqualValues(t, "IVF_HNSW", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		nlist, M, efConstruction = 0, 16, 40
		idx0, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		nlist, M, efConstruction = 65537, 16, 40
		idx1, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
		nlist, M, efConstruction = 10, 3, 40
		idx2, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx2)
		
		nlist, M, efConstruction = 10, 65, 40
		idx3, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx3)
		
		nlist, M, efConstruction = 10, 16, 7
		idx4, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx4)
		
		nlist, M, efConstruction = 10, 16, 513
		idx5, err := NewIndexIvfHNSW(mt, 
			nlist,
			M,
			efConstruction,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx5)
		
	})
}

func TestIndexANNOY(t *testing.T){
	
	var n_trees int

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		n_trees = 8
		idx0, err := NewIndexANNOY(mt, 
			n_trees,
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "ANNOY", idx0.Name())
		assert.EqualValues(t, "ANNOY", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
		n_trees = 0
		idx0, err := NewIndexANNOY(mt, 
			n_trees,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx0)
		
		n_trees = 1025
		idx1, err := NewIndexANNOY(mt, 
			n_trees,
		)
		assert.NotNil(t, err)
		assert.Nil(t, idx1)
		
	})
}

func TestIndexDISKANN(t *testing.T){
	

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		
		idx0, err := NewIndexDISKANN(mt, 
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "DISKANN", idx0.Name())
		assert.EqualValues(t, "DISKANN", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
	})
}

func TestIndexAUTOINDEX(t *testing.T){
	

	mt := L2
	

	t.Run("valid usage case", func(t *testing.T){
		
		
		idx0, err := NewIndexAUTOINDEX(mt, 
		)
		assert.Nil(t, err)
		assert.NotNil(t, idx0)
		assert.Equal(t, "AUTOINDEX", idx0.Name())
		assert.EqualValues(t, "AUTOINDEX", idx0.IndexType())
		assert.NotNil(t, idx0.Params())
		assert.False(t, idx0.SupportBinary())
		
	})

	t.Run("invalid usage case", func(t *testing.T){
		
	})
}

