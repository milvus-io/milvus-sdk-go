package main

import (
	"fmt"
	"os"
	"text/template"

	"github.com/milvus-io/milvus-sdk-go/v2/entity"
)

var arrayColumnTmpl = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT
// This file is generated by go generate 

package entity 

import (
	"fmt"

	"github.com/cockroachdb/errors"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
)

{{ range .Types }}{{with .}}
// Column{{.TypeName}}Array generated columns type for {{.TypeName}}
type Column{{.TypeName}}Array struct {
	ColumnBase
	name   string
	values [][]{{.TypeDef}}
	validValues []bool
	nullable    bool
}

// Name returns column name
func (c *Column{{.TypeName}}Array) Name() string {
	return c.name
}

// Type returns column FieldType
func (c *Column{{.TypeName}}Array) Type() FieldType {
	return FieldTypeArray
}

// Len returns column values length
func (c *Column{{.TypeName}}Array) Len() int {
	return len(c.values)
}

// Nullable returns column values nullable
func (c *Column{{.TypeName}}Array) Nullable() bool {
	return c.nullable
}

// Slice returns column slice
func (c *Column{{.TypeName}}Array) Slice(start, end int) Column {
	l := c.Len()
	if start > l {
		start = l
	}
	if end == -1 || end > l {
		end = l
	}
	sliceValidValues := make([]bool, 0)
	if c.nullable {
		sliceValidValues = c.validValues[start:end]
	}
	return &Column{{.TypeName}}Array{
		ColumnBase:  c.ColumnBase,
		name:        c.name,
		values:      c.values[start:end],
		validValues: sliceValidValues,
		nullable:    c.nullable,
	}
}

// Get returns value at index as interface{}.
func (c *Column{{.TypeName}}Array) Get(idx int) (interface{}, error) {
	var r []{{.TypeDef}} // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	if c.nullable {
		if idx < 0 || idx >= len(c.validValues) {
			return nil, errors.New("index out of validValues range")
		}
		if !c.validValues[idx] {
			return nil, nil
		}
	}
	return c.values[idx], nil
}

// FieldData return column data mapped to schemapb.FieldData
func (c *Column{{.TypeName}}Array) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Array,
		FieldName: c.name,
		ValidData: c.validValues,
	}

	convertTo := func(arr []{{.PbType}}) *schemapb.ScalarField {
		converted := make([]{{.PbType}}, 0, c.Len())
		for i := 0; i < len(arr); i++ {
			converted = append(converted, {{.PbType}}(arr[i]))
		}
		return &schemapb.ScalarField{
			Data: &schemapb.ScalarField_{{.PbName}}Data{
				{{.PbName}}Data: &schemapb.{{.PbName}}Array{
					Data: converted,
				},
			},
		}
	}

	data := make([]*schemapb.ScalarField, 0, c.Len())
	if c.nullable {
		for i, v := range c.validValues {
			if v {
				data = append(data, convertTo(c.values[i]))
			}
		}
	} else {
		for _, arr := range c.values {
			data = append(data, convertTo(arr))
		}
	}

	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_ArrayData{
				ArrayData: &schemapb.ArrayArray{
					Data:        data,
					ElementType: schemapb.DataType_{{.TypeName}},
				},
			},
		},
	}
	return fd
}

// ValueByIdx returns value of the provided index
// error occurs when index out of range
func (c *Column{{.TypeName}}Array) ValueByIdx(idx int) ([]{{.TypeDef}}, error) {
	var r []{{.TypeDef}} // use default value
	if idx < 0 || idx >= c.Len() {
		return r, errors.New("index out of range")
	}
	if c.nullable {
		if idx < 0 || idx >= len(c.validValues) {
			return r, errors.New("index out of validValues range")
		}
		if !c.validValues[idx] {
			return nil, nil
		}
	}
	return c.values[idx], nil
}

// AppendValue append value into column
func(c *Column{{.TypeName}}Array) AppendValue(i interface{}) error {
	var v []{{.TypeDef}}
	if i == nil && c.nullable {
		c.values = append(c.values, v)
		c.validValues = append(c.validValues, false)
		return nil
	}
	v, ok := i.([]{{.TypeDef}})
	if !ok {
		return fmt.Errorf("invalid type, expected []{{.TypeDef}}, got %T", i)
	}
	c.values = append(c.values, v)
	if c.nullable {
		c.validValues = append(c.validValues, true)
	}

	return nil
}

// Data returns column data
func (c *Column{{.TypeName}}Array) Data() [][]{{.TypeDef}} {
	return c.values
}

// ValidData returns column ValidData
func (c *Column{{.TypeName}}Array) ValidData() []bool {
	return c.validValues
}

// NewColumn{{.TypeName}} auto generated constructor
func NewColumn{{.TypeName}}Array(name string, values [][]{{.TypeDef}}) *Column{{.TypeName}}Array {
	return &Column{{.TypeName}}Array {
		name: name,
		values: values,
	}
}

// NewColumn{{.TypeName}} auto generated constructor
func NewNullableColumn{{.TypeName}}Array(name string, values [][]{{.TypeDef}}, validValues []bool) *Column{{.TypeName}}Array {
	return &Column{{.TypeName}}Array {
		name: name,
		values: values,
		nullable:    true,
		validValues: validValues,
	}
}

// NewAllNullColumn{{.TypeName}} auto generated constructor
func NewAllNullColumn{{.TypeName}}Array(name string, rowSize int) *Column{{.TypeName}}Array {
	return &Column{{.TypeName}}Array {
		name: name,
		values: make([][]{{.TypeDef}},rowSize),
		nullable:    true,
		validValues: make([]bool,rowSize),
	}
}
{{end}}{{end}}
`))

func main() {
	arrElementTypes := []entity.FieldType{
		entity.FieldTypeBool,
		entity.FieldTypeInt8,
		entity.FieldTypeInt16,
		entity.FieldTypeInt32,
		entity.FieldTypeInt64,
		entity.FieldTypeFloat,
		entity.FieldTypeDouble,
		// entity.FieldTypeVarChar, change to hand written
	}

	pf := func(ft entity.FieldType) interface{} {
		pbName, pbType := ft.PbFieldType()
		return struct {
			TypeName string
			TypeDef  string
			PbName   string
			PbType   string
		}{
			TypeName: ft.Name(),
			TypeDef:  ft.String(),
			PbName:   pbName,
			PbType:   pbType,
		}
	}

	fn := func(fn string, types []entity.FieldType, tmpl *template.Template, pf func(entity.FieldType) interface{}) {
		params := struct {
			Types []interface{}
		}{
			Types: make([]interface{}, 0, len(types)),
		}
		for _, ft := range types {
			params.Types = append(params.Types, pf(ft))
		}
		f, err := os.OpenFile(fn, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
		if err != nil {
			fmt.Println(err.Error())
			return
		}
		defer f.Close()

		tmpl.Execute(f, params)
	}
	fn("columns_array_gen.go", arrElementTypes, arrayColumnTmpl, pf)
}
